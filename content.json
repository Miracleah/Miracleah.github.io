{"meta":{"title":"Miracle","subtitle":"把真诚和热爱趁年轻全部浪费掉","description":"这是我的博客测试描述，看看它会出现在哪个地方","author":"Miracle","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"环形链表","slug":"环形链表相关问题","date":"2022-10-12T06:57:36.006Z","updated":"2022-10-12T09:01:59.681Z","comments":true,"path":"2022/10/12/环形链表相关问题/","link":"","permalink":"http://example.com/2022/10/12/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/","excerpt":"两道环形链表OJ题","text":"两道环形链表OJ题 环形链表相关问题 环形链表I 此问题的总结来源于两道环形链表的OJ题：环形链表I、环形链表II 先来看看环形链表I ，题目的是这样的： 按照题目的表述，我们知道如果一个链表不含环，那我通过遍历链表总能找到尾结点。但如果含环，那遍历这个链表就是死循环。我看到这题，可以说是毫无思路，因为我除了遍历也想不到其他的法子。 我了解到“快慢指针”可以很完美的解决这道题。它是这么想的： 定义两个指针：slowslowslow和fastfastfast，让slowslowslow每次后移一个节点，fastfastfast每次后移两个结点，如果这个单链表中存在换，当fastfastfast和slowslowslow都进环以后，fastfastfast一定可以追上slowslowslow。抽象成一个数学问题就是，一个跑的慢的人和一个跑的快的人，从不同起点出发，在环形跑道内跑步，在以后的某一个时刻，跑的快的人一定可以追上跑的慢的人。这是一个很典型的“追击问题”。 ​ 示意图 如果fast最后指向了空，那就说明这个链表中是不存在环的。 如果能想明白这个逻辑，那这道题的实现是非常简单的： 1234567891011121314bool hasCycle(struct ListNode *head) &#123; struct ListNode *fast = head; struct ListNode *slow = head; while(fast != NULL &amp;&amp; fast-&gt;next != NULL) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; if(fast == slow) &#123; return true; &#125; &#125; return false;&#125; 做完这道题，不妨思考思考这几个问题： fastfastfast一定可以追上slowslowslow吗？即fast=slowfast = slowfast=slow；有没有可能它们永远不会相遇？ lowlowlow一次走1步，fastfastfast一次走3步，行不行？4步呢？5步呢？ 简单想一想第一个问题，直观感觉上如果fastfastfast一次不走2步，可能fast快碰到slowslowslow的时候会直接跳过slowslowslow，那这样fastfastfast可能不会与slowslowslow相遇。下面我们需要推导证明这一结论。 证明：设slow指针的速度为1,fast指针的速度为3.当slow进环以后它们之间的距离为N.假设它们能恰好相遇，经历的时间为t.环的长度为C则有：1×t+N=3×t解得：N=2×t这表明在fast还没有超过slow之前，当且仅当它们之间的距离N为偶数时，fast第一次才会恰好等于slow.如果N不为偶数，那fast第一次超过slow时，一定是在slow的后一个位置。此时，fast和slow的距离N=C−1.根据上述讨论，只有C−1为偶数时，它们才可能相遇. 综上所述：当slow第一次进环时，它们之间的距离N为偶数或N为奇数且C−1为偶数时，fast与slow才会相遇。除此之外，fast与slow都不会相遇。 \\begin{aligned} 证明：\\\\ &amp;设slow指针的速度为1,fast指针的速度为3.当slow进环以后它们之间的距离为N.\\\\ &amp;假设它们能恰好相遇，经历的时间为t.环的长度为C\\\\ &amp;则有：\\\\ &amp;\\qquad \\qquad \\qquad \\qquad \\qquad 1\\times t + N = 3\\times t \\\\ &amp;解得：\\\\ &amp;\\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\quad N = 2\\times t \\\\ &amp;这表明在fast还没有超过slow之前，当且仅当它们之间的距离N为偶数时，fast第 \\\\ &amp;一次才会恰好等于slow. \\\\ &amp;如果N不为偶数，那fast第一次超过slow时，一定是在slow的后一个位置。此时，\\\\ &amp;fast和slow的距离N = C - 1.根据上述讨论，只有C-1为偶数时，它们才可能 \\\\ &amp;相遇. ~\\\\ &amp;综上所述：\\\\ &amp;当slow第一次进环时，它们之间的距离N为偶数或N为奇数且C-1为偶数时，fast \\\\ &amp;与slow才会相遇。除此之外，fast与slow都不会相遇。 \\end{aligned} 证明：​设slow指针的速度为1,fast指针的速度为3.当slow进环以后它们之间的距离为N.假设它们能恰好相遇，经历的时间为t.环的长度为C则有：1×t+N=3×t解得：N=2×t这表明在fast还没有超过slow之前，当且仅当它们之间的距离N为偶数时，fast第一次才会恰好等于slow.如果N不为偶数，那fast第一次超过slow时，一定是在slow的后一个位置。此时，fast和slow的距离N=C−1.根据上述讨论，只有C−1为偶数时，它们才可能相遇. 综上所述：当slow第一次进环时，它们之间的距离N为偶数或N为奇数且C−1为偶数时，fast与slow才会相遇。除此之外，fast与slow都不会相遇。​我以fastfastfast一次走3步为例，简单讨论了slowslowslow与fastfastfast会不会相遇的问题。当fastfastfast一次走444步时，推导过程类似。此时NNN要满足NNN为3的倍数，或者CCC满足C−1C-1C−1、C−2C-2C−2均为333的倍数时，才会相遇。 由此，总结出一般规律： 当slow一次走1步，fast一次走n步时，当且仅当N为(n−1)的倍数或C−1,C−2,…,C−(n−2)均为3的倍数时，才能保证fast一定可以与slow相遇。 \\begin{aligned} &amp;当slow一次走1步，fast一次走n步时，当且仅当N为(n-1)的倍数或C-1,C-2,\\ldots,C-(n-2)\\\\ &amp;均为3的倍数时，才能保证fast一定可以与slow相遇。 \\end{aligned} ​当slow一次走1步，fast一次走n步时，当且仅当N为(n−1)的倍数或C−1,C−2,…,C−(n−2)均为3的倍数时，才能保证fast一定可以与slow相遇。​ 环形链表II 题目是这样表述的： 此题可以说是上一题的升级版，难度也有所增加。和上一题一样，我对此题也束手无策，只好从结果出发，总结总结此题。 首先最外层的肯定是先判断给的链表是否含环，这和上一题是一模一样的，难点就在于怎么找到环的入口，那就是最后一个结点的nextnextnext所指向的节点。针对此题，有一个结论： 当slowslowslow进环以后，fastfastfast第一次与slowslowslow相遇时的节点到入口的距离等于链表第一个节点到环入口的距离。 简言之，就是：记slowslowslow与fastfastfast第一次相遇时的节点为meetmeetmeet，第一个节点为headheadhead，他们同时开始nextnextnext，那最终一定会在环入口处相遇。 下面我们来推导证明这一结论： ​ 示意图 证明：设第一个节点到环入口的距离为L，环长为C，第一次相遇时slow在环内走过的距离为x.分析可知：1、slow在环内走不完一圈，fast就会追上slow.2、fast与slow相遇时，fast在环内走了nC+x的距离.(比较难想)由已知条件：fast走的比slow快2倍可知，它们走过的距离也是2倍的关系.则可列方程：L+nC+x=2(L+x)解得：nC=L+x为了便于理解，可将上述解写为：(n−1)C+C−x=L易知：C−x为第一次相遇时的位置到环入口处的距离,那么头结点到环入口的距离L就等于fast和slow第一次相遇时的位置到环入口处的距离再加上环长的整数倍.这就意味着如果head指针和meet指针同时以每次移动1步的速度向后走，那么它们一定会在环的入口处相遇. \\begin{aligned} 证明：\\\\&amp; 设第一个节点到环入口的距离为L，环长为C，第一次相遇时slow在环内走过的距离为x.\\\\ &amp; 分析可知：\\\\ &amp; 1、slow在环内走不完一圈，fast就会追上slow.\\\\ &amp; 2、fast与slow相遇时，fast在环内走了nC+x的距离.(比较难想) \\\\ &amp; 由已知条件：fast走的比slow快2倍可知，它们走过的距离也是2倍的关系.\\\\ &amp; 则可列方程：\\\\ &amp; \\qquad \\qquad \\qquad \\qquad L+nC+x = 2(L+x)\\\\ &amp;解得：\\\\ &amp;\\qquad \\qquad \\qquad \\qquad \\qquad \\quad nC = L +x \\\\ &amp;为了便于理解，可将上述解写为：\\\\ &amp;\\qquad \\qquad \\qquad \\qquad (n-1)C+C-x = L\\\\ &amp;易知：C-x为第一次相遇时的位置到环入口处的距离,那么头结点到环入口的距离L\\\\ &amp;\\qquad 就等于fast和slow第一次相遇时的位置到环入口处的距离再加上环长的整数倍.\\\\ &amp;\\qquad 这就意味着如果head指针和meet指针同时以每次移动1步的速度向后走，那么\\\\ &amp;\\qquad 它们一定会在环的入口处相遇. \\end{aligned} 证明：​设第一个节点到环入口的距离为L，环长为C，第一次相遇时slow在环内走过的距离为x.分析可知：1、slow在环内走不完一圈，fast就会追上slow.2、fast与slow相遇时，fast在环内走了nC+x的距离.(比较难想)由已知条件：fast走的比slow快2倍可知，它们走过的距离也是2倍的关系.则可列方程：L+nC+x=2(L+x)解得：nC=L+x为了便于理解，可将上述解写为：(n−1)C+C−x=L易知：C−x为第一次相遇时的位置到环入口处的距离,那么头结点到环入口的距离L就等于fast和slow第一次相遇时的位置到环入口处的距离再加上环长的整数倍.这就意味着如果head指针和meet指针同时以每次移动1步的速度向后走，那么它们一定会在环的入口处相遇.​通过上面的分析，很容易就可以写出代码。此题的难点就在于发现这个结论，感觉回到了一个数学问题上。 12345678910111213141516171819202122struct ListNode *detectCycle(struct ListNode *head) &#123; struct ListNode *fast = head; struct ListNode *slow = head; while(fast != NULL &amp;&amp; fast-&gt;next != NULL) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; if(fast == slow) &#123; //相遇 struct ListNode *meet = fast; struct ListNode *cur = head; while(cur != meet) &#123; cur = cur-&gt;next; meet = meet-&gt;next; &#125; return cur; &#125; &#125; return NULL;&#125; 喔…终于写完了-.- -----------------------------------------------------------------------------------end--------------------------------------------------------------------------------------------------","categories":[],"tags":[]},{"title":"题解记录","slug":"顺序表OJ","date":"2022-09-15T04:28:07.039Z","updated":"2022-09-21T15:46:03.742Z","comments":true,"path":"2022/09/15/顺序表OJ/","link":"","permalink":"http://example.com/2022/09/15/%E9%A1%BA%E5%BA%8F%E8%A1%A8OJ/","excerpt":"两道OJ题","text":"两道OJ题 Question 1 移除元素 这个题并不是很难，读完题脑子里的第一反应就是遍历整个数组，把满足条件的值剔除，再返回新数组的长度就行了。整个逻辑还是比较清晰的。 画个图，帮助我们更清楚的理解： (图片) 把p假想成一个指针，现在的问题就是怎么用代码把图片表达的想法表示出来。由于使用覆盖的方法把数组中的值“剔除”，所以遇到满足条件时，“指针”p是不需要移动的，这点很重要。 第一次我使用for循环遍历数组，遇到目标值就覆盖，并记录覆盖的次数以返回新数组的长度： 123456789101112131415int removeElement(int* nums, int numsSize, int val)&#123; int p = 0, count = 0; for(int i = 0; i &lt; numsSize; i++) &#123; if(nums[i-count] == val) &#123; for(p = i - count; p &lt; numsSize - 1; p++) &#123; nums[p] = nums[p+1]; &#125; count++; &#125; &#125; return numsSize - count;&#125; ​ 用for循环遍历数组时，如果遇到满足条件的值，覆盖以后，“指针”p是不需要向后移动的，但每循环一次，i就会做一次自增，所以需要对p做一定的修改。用count记录覆盖了几次，同时用 i - count，可以有对“指针”p的回溯效果。我在这里错了好几次才发现需要减去count 。 ​ 同时，我觉得这个题使用while循环会比for循环更方便，因为不会被 i 的值折磨 : 123456789101112131415161718192021int removeElement(int* nums, int numsSize, int val)&#123; int p = 0, count = 0; int changetimes = 0; while(count &lt; numsSize) &#123; if(nums[p] == val) &#123; for(int i = p; i &lt; numsSize - 1; i++) &#123; nums[i] = nums[i+1]; &#125; changetimes++; &#125; else &#123; p++; &#125; count++; &#125; return numsSize - changetimes;&#125; ​ 分析上面算法的时间复杂度，考虑最坏的情况：数组中的每个值都是目标值。那覆盖的操作要进行： (n−1)+(n−2)+⋯+2+1 (n-1)+(n-2)+\\cdots+2+1 (n−1)+(n−2)+⋯+2+1 ​ 这么多次，上式是一个等差数列，可得它的时间复杂度是O(n2)O(n^2)O(n2) , 空间复杂度是O(1)O(1)O(1) 。跳出题目的限制，考虑能不能优化上述算法，使其时间复杂度为O(n)O(n)O(n) ？ ​ 尝试用空间复杂度去换时间复杂度，也就是额外开辟一块空间来辅助完成任务。和上一种方法的思路类似。可以再开辟一个和原数组大小相同的数组，然后遍历一遍题目所给的数组，将所有符合条件的值搬到新数组中，并记录次数，然后把新数组复制给原数组。具体代码如下： 1234567891011121314151617int removeElement(int* nums, int numsSize, int val)&#123; int a[100] = &#123; 0 &#125;; int count = 0; for (int i = 0; i &lt; numsSize; i++) &#123; if (nums[i] != val) &#123; a[count] = nums[i]; count++; &#125; &#125; for (int i = 0; i &lt;= count; i++) &#123; nums[i] = a[i]; &#125; return count;&#125; ​ 相比于上一个解法，降低了时间复杂度，但是空间复杂度提高了。本题要求我们不使用额外的空间，所以此解法是不满足要求的，只是提供一种额外的想法。 ​ 有没有可能找到一种算法，只遍历一遍数组而不使用额外的空间，也就是时间复杂度为O(n)O(n)O(n) ,空间复杂度为 O(1)O(1)O(1)呢？答案是肯定的，只遍历一遍，在原数组的基础上修改就行。这时我们可以利用“双指针”来完成，其基本思路如下图： （图片） 代码如下： 1234567891011121314151617int removeElement(int* nums, int numsSize, int val)&#123; int src = 0, dst = 0; while(src &lt; numsSize) &#123; if(nums[src] != val) &#123; nums[dst] = nums[src]; src++; dst++; &#125; else &#123; src++; &#125; &#125; return dst;&#125; 本题不算难，但最优解往往是不容易想到的，这种由浅及深，一步步优化算法的思想是值得我学习的，我认为这种品质是难得的。 Question2 [删除有序数组中的重复项] 由于给定的数组是升序排列的，所以数组中出现的重复元素都是连续的（比如1 2 2 2 3）这种，重复的数字都是一段一段的，扫描整个数组如果发现前后两个数字不同，那就比较下两个。如果相同，那只用移动后面的那个“指针”，直到找到第一个不同的数字，就说明走完了这个相同数字的一段。然后将这个不同的数字覆盖到第一个相同数字的后面。文字描述比较繁琐，直接上图： （图片） 12345678910111213141516171819int removeDuplicates(int* nums, int numsSize)&#123; int i = 0, j = 1, dst = 0; for(j = 1; j &lt; numsSize; ) &#123; if(nums[i] == nums[j]) &#123; j++; &#125; else &#123; nums[dst] = nums[i]; i = j; j++; dst++; &#125; &#125; nums[dst] = nums[i]; return dst + 1;&#125; ​ 这题比上题的第三种解法还多用了一个“指针”，其实也不太好想，只好积累下来罢。 ​ 最近学习效率不高，状态低迷，网课欠下了许多债，内容学起来也不轻松，简直就是折磨啊。。。。。。 想了想还是赶紧补完这篇吧，不然这写了一半的东西再拖恐怕就烂尾了。（=.=","categories":[],"tags":[]},{"title":"在动态数组尾部插入或删除元素","slug":"在动态数组尾部插入或删除元素","date":"2022-09-13T15:01:37.626Z","updated":"2022-09-15T03:19:19.577Z","comments":true,"path":"2022/09/13/在动态数组尾部插入或删除元素/","link":"","permalink":"http://example.com/2022/09/13/%E5%9C%A8%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E5%B0%BE%E9%83%A8%E6%8F%92%E5%85%A5%E6%88%96%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0/","excerpt":"数据结构中对顺序表的基本操作。","text":"数据结构中对顺序表的基本操作。 ​ 在 C 语言中，学习了数组这一数据类型，它的作用就是将一系列类型相同的数据连续的存起来，在需要使用时，也能很快的访问。学习了指针以后，了解到：数组的本质其实是指针。定义了一个固定长度的数组，就相当于定义了一个指针，这个指针指向了固定长度的地址。并且，这些地址都是连续的。所以可以快速的访问数组中的任一元素。 ​ 数据结构开篇即介绍了线性表的顺序表示，如果是静态的线性表，那在C语言中就是一维数组，对线性表操作就可以理解为对数组进行操作。对数组进行基本操作是比较简单易懂的。由于在学习 C 语言时，对于指针和结构体不是很熟悉，所以本篇着重整理对在 C 语言中对动态分配的一维数组的一些基本操作。 在动态分配的一维数组尾部插入元素 创建一个动态分配的一维数组 首先重定义一个结构体: 12345678typedef int SLDataType; //重定义inttypedef struct SeqList //重定义结构体为SL{ SLDataType* a; int size; // size表示顺序表的元素的个数 int capacity; // capacity表示顺序表能存的元素个数}SL; 这里使用 typedef 定义 int 的好处是如果需要修改数组中存储元素的类型，则只需要在 typedef 中修改一次。如果不使用这种方法，则需要修改代码中的所有int类型，显然是不利于代码的维护的。 初始化数组 定义一个函数来初始化数组，将a指针初始化为空指针，size 和 capacity 初始化为0。 1234567void SeqListInit(SL* ps) //结构体指针{ ps-&gt;a = NULL; ps-&gt;size = ps-&gt;capacity = 0; //初始化数组} 实现尾插函数（关键） 怎样实现对数组长度的动态分配呢？这对于我来说却是是一个不简单的问题，这个问题让我难以下手。高中的时候，遇到无从下手的题，我一般用特殊值，或者临界状态去试着打开突破口。所以，解决这个问题不妨从临界状态开始分析： 从图中可以看出，有两种情况需要对数组进行扩容： 1、需要插入元素，但是数组已经满了，也就是数组元素的个数等于数组的容量了。 2、需要插入元素，但数组是空的（没有空间）。 所以我们就得出了什么时候应该对数组进行扩容。除此之外数组是不需要扩容的，也就是说可以直接在最后一个元素后面插入新的元素。 通过上面的分析，不难得出一下if语句： 1234if (ps-&gt;size == ps-&gt;capacity){ 扩容；} 由前面定义可知，数组的容量用 capacity 表示，扩容就是扩大 capacity 的值。这是不难的，直接对 capacity*2 即可。由于考虑到数组是空的，即（capacity=0）这种情况，所以得多加一个判断条件，判断其是否为0，如果不判断，那*2有时也没意义。 实现扩容就得知道 realloc 这个函数 realloc函数是将数组扩容的一个函数，它的用法是： 指针名= （数据类型*）realloc（需要改变内存大小的指针名，新的大小） ，值得注意的是：“新的大小” 是字节。有时需要乘上sizeof（数据类型） 当需要改变内存大小的指针是空指针时，它的作用相当于malloc函数。 用以下语句就可以实现扩容： 12345678910//如果没有空间。或者空间不足，就进行扩容 int newcapacity = ps-&gt;capacity == 0 ? 4 : ps-&gt;capacity * 2; //三目运算符。扩2倍比较合适 SLDataType* tmp = (SLDataType*)realloc(ps-&gt;a, newcapacity * sizeof(SLDataType)); //扩容的是字节数，要强制类型转化 if (tmp == NULL) // 检查扩容是否成功 { printf(\"realloc failed\\n\"); exit(-1); //未成功强制退出程序 } ps-&gt;a = tmp; ps-&gt;capacity = newcapacity; 用以下语句在胃部插入元素： 12 ps-&gt;a[ps-&gt;size] = x; //下标从0开始ps-&gt;size++; 完整的函数如下： 1234567891011121314151617181920void SeqListPushBack(SL* ps, SLDataType x) //实现对顺序表尾部插入元素的函数{ if (ps-&gt;size == ps-&gt;capacity) { //如果没有空间。或者空间不足，就进行扩容 int newcapacity = ps-&gt;capacity == 0 ? 4 : ps-&gt;capacity * 2; //三目运算符。扩2倍比较合适 SLDataType* tmp = (SLDataType*)realloc(ps-&gt;a, newcapacity * sizeof(SLDataType)); //扩容的是字节数，要强制类型转化 if (tmp == NULL) // 检查扩容是否成功 { printf(\"realloc failed\\n\"); exit(-1); //未成功强制退出程序 } ps-&gt;a = tmp; ps-&gt;capacity = newcapacity; } //空间足够。直接在表尾插入 ps-&gt;a[ps-&gt;size] = x; //下标从0开始 ps-&gt;size++;} 在动态分配的一维数组尾部删除元素 相对于插入元素，删除元素没有数组长度是否足够的问题，所以也比较简单。 考虑直接忽略尾部的元素，即对 size 进行减法。有一个需要注意的点就是数组中元素的长度size必须是大于0的，如果小于0那就没意义了，所以如果不增加这个限制条件而对 size 进行减法程序可能会报错。 具体实现如下： 123456789void SeqListPopBack(SL* ps) //尾删{ if (ps-&gt;size &gt; 0) { ps-&gt;size--; } //assert(ps-&gt;size &gt; 0); //ps.size--;} 如上，还有另外一种写法就是使用assert函数，它表示只有括号内的表达式为真时，程序才会往下执行。","categories":[],"tags":[]},{"title":"LaTeX使用的一些总结","slug":"LaTeX使用的一些总结","date":"2022-05-26T15:17:54.923Z","updated":"2022-09-15T07:32:14.701Z","comments":true,"path":"2022/05/26/LaTeX使用的一些总结/","link":"","permalink":"http://example.com/2022/05/26/LaTeX%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/","excerpt":"闲来无事，整理一下可能会用到的一些LaTex知识","text":"闲来无事，整理一下可能会用到的一些LaTex知识 LaTeX数学公式 本文主要总结在使用Markdown编写LaTeX数学公式时，会用到的一些知识。 希腊字母 使用\\小写希腊字母英文全称和\\首字母大写的希腊字母英文全称来表示小写、大写希腊字母，对于大写首字母与大写希腊字母相同的，直接输入大写的首字母即可。 下表是常见的希腊字母： 输入 显示 输入 显示 \\alpha α\\alphaα A AAA \\beta β\\betaβ B BBB \\gamma γ\\gammaγ \\Gamma Γ\\GammaΓ \\delta δ\\deltaδ \\Delta Δ\\DeltaΔ \\epsilon ϵ\\epsilonϵ E EEE \\zeta ζ\\zetaζ Z ZZZ \\eta η\\etaη H HHH \\theta θ\\thetaθ \\Theta Θ\\ThetaΘ \\iota ι\\iotaι I III \\kappa κ\\kappaκ K KKK \\lambda λ\\lambdaλ \\Lambda Λ\\LambdaΛ \\nu ν\\nuν N NNN \\mu μ\\muμ M MMM \\xi ξ\\xiξ \\Xi Ξ\\XiΞ o ooo O OOO \\pi π\\piπ \\Pi Π\\PiΠ \\rho ρ\\rhoρ P PPP \\sigma σ\\sigmaσ \\Sigma Σ\\SigmaΣ \\tau τ\\tauτ T TTT \\upsilon υ\\upsilonυ \\Upsilon Υ\\UpsilonΥ \\phi ϕ\\phiϕ \\Phi Φ\\PhiΦ \\chi χ\\chiχ X XXX \\psi ψ\\psiψ \\Psi Ψ\\PsiΨ \\omega ω\\omegaω \\Omega Ω\\OmegaΩ 编号 编辑数学公式时，我们有时候需要给这个公式或者式子编号，以便后续引用它方便。在公式末尾使用\\tag{序号}来对公式进行编号，其中“序号”可以为任意你想定义的内容。例如： f(x)=x2(1-1) f(x)=x^2\\tag{1-1} f(x)=x2(1-1) 运算符 一些简单的运算符，如：+、-我们可以直接从键盘中输入，但对于一些复杂运算符，如：×\\times× ,÷\\div÷,∈\\in∈ 等我们是无法直接从键盘中输入的。所以我们就要借助代码实现这些运算符的输入，下表给出了常见的运算符极其代码： 代码 运算符 代码 运算符 \\pm ±\\pm± \\emptysey ∅\\emptyset∅ \\times ×\\times× $\\in$ ∈\\in∈ \\div ÷\\div÷ \\notin ∉\\notin∈/ \\leq 或\\le ≤\\leq≤ \\subset ⊂\\subset⊂ \\geq 或ge ≥\\geq≥ \\supset ⊃\\supset⊃ \\not&gt; &gt;̸\\not&gt;&gt; \\not\\subset ⊄\\not\\subset⊂ \\neq 或\\ne ≠\\neq= \\subseteq ⊆\\subseteq⊆ \\equiv ≡\\equiv≡ \\supseteq ⊇\\supseteq⊇ \\ll ≪\\ll≪ \\cap ∩\\cap∩ \\gg ≫\\gg≫ \\cup ∪\\cup∪ \\sum ∑\\sum∑ \\prec ≺\\prec≺ \\prod ∏\\prod∏ \\preceq ⪯\\preceq⪯ \\coprod ∐\\coprod∐ \\succ ≻\\succ≻ \\sim ∼\\sim∼ \\succeq ⪰\\succeq⪰ \\backsim ∽\\backsim∽ \\vee ∨\\vee∨ \\cong ≅\\cong≅ \\wedge ∧\\wedge∧ \\approx ≈\\approx≈ \\bot ⊥\\bot⊥ \\because ∵\\because∵ \\angle ∠\\angle∠ \\therefore ∴\\therefore∴ 30^\\circ 30∘30^\\circ30∘ \\forall ∀\\forall∀ \\infty ∞\\infty∞ \\exists ∃\\exists∃ \\neg ¬\\neg¬ \\odot ⊙\\odot⊙ \\oplus ⊕\\oplus⊕ \\otimes ⊗\\otimes⊗ \\circ ∘\\circ∘ 一些常用的箭头： 代码 符号 代码 符号 \\uparrow ↑\\uparrow↑ \\downarrow ↓\\downarrow↓ \\updownarrow ↕\\updownarrow↕ \\Uparrow ⇑\\Uparrow⇑ \\Downarrow ⇓\\Downarrow⇓ \\Updownarrow ⇕\\Updownarrow⇕ \\to或\\rightarrow →\\to→ \\gets 或leftarrow ←\\gets← \\Rightarrow ⇒\\Rightarrow⇒ \\Leftarrow ⇐\\Leftarrow⇐ \\Leftrightarrow ⇔\\Leftrightarrow⇔ \\longrightarrow ⟶\\longrightarrow⟶ \\longleftarrow ⟵\\longleftarrow⟵ \\Longrightarrow ⟹\\Longrightarrow⟹ \\Longleftarrow ⟸\\Longleftarrow⟸ \\Longleftrightarrow ⟺\\Longleftrightarrow⟺ \\rightharpoonup ⇀\\rightharpoonup⇀ \\leftharpoonup ↼\\leftharpoonup↼ \\rightharpoondown ⇁\\rightharpoondown⇁ \\leftharpoondown ↽\\leftharpoondown↽ 还有一些特殊符号，例如： 给箭头上方添加备注：\\xrightarrow{tips} : →tips\\xrightarrow{tips}tips​ 转义字符和注释 转义字符 在LaTeX语法中，“_”和 “^” 分别可以编辑下标和上标，如果我们的公式中本身就含有 “_” 和 “^” ，则需要在此之前添加一个反斜杠来转义它。在typora中，遇到类似的问题也是一样的。 注释 在LaTeX公式中，我们可以使用一个百分号% 为公式添加注释，例如：%这是一个二次函数 换行与对齐 换行 如果写完一个公式需要换行写下一个，只需在上一个公式的末尾添加 “\\” ，最后一行的公式末尾可加可不加。 5+3×5=5+15=20 5+3\\times5\\\\ =5+15\\\\ =20 5+3×5=5+15=20 但我们发现上面的式子丑极了，因为它每一行并不是对齐的。下面就是对齐它们的方法。 对齐 在公式的开头写上\\begin{aligned} 结尾写上\\end{aligned} ，并在需要对齐的位置标上&amp;符号。以下是对齐后的效果： 5+3×5=5+15=20 \\begin{aligned} &amp;\\quad 5+3\\times5\\\\ &amp;=5+15\\\\ &amp;=20 \\end{aligned} ​5+3×5=5+15=20​ 字体 如果需要对公式中的字体进行改变，可以使用”\\字体代号{需要改变的内容}“ 来修改，公式中默认为意大利体，直体为罗马体。效果如下： A+B=D A+\\bf{B}=\\mathbb{D} A+B=D 下面的表格给出了常见的字体以及其对应的代号： 字体代号 字体 显示 \\mathit 或 \\it 斜体（默认，意大利体） DDD \\mathrm 或 \\rm 罗马体 D\\rm{D}D \\mathbf 或 \\bf 粗体 D\\bf{D}D \\mathbb 黑板粗体 D\\mathbb{D}D \\mathsf 或 \\sf 等线体 D\\sf{D}D \\mathcal 花体 D\\mathcal{D}D \\mathscr 手写体 D\\mathscr{D}D \\mathtt 打字机体 D\\mathtt{D}D \\mathfrak 哥特体 D\\mathfrak{D}D \\boldsymbol 黑体 D\\boldsymbol{D}D 空格 使用\\quad 可以空一格，\\qquad可以空两格。值得注意的是\\qqquad并不能实现空三格，它是不合法的。 括号 () 、[] 、| 它们直接输入就可以表示自己。使用\\{\\} 来表示{} 。当我们需要使用大号的括号和分隔符时，可以使用\\left \\right命令： \\left(表达式\\right) . 其中”()“可以改变成其他想要大号的括号。例如： lim⁡x→+∞(1+1x)x=e(1-4) \\lim_{x \\to +\\infty}\\left(1+\\frac{1}{x}\\right)^x=e \\tag{1-4} x→+∞lim​(1+x1​)x=e(1-4) 有时候我们会用到\\left. 和\\right. 进行匹配而不显示本身： dudx∣x=0 \\left. \\frac{ {\\rm d}u}{ {\\rm d}x} \\right| _{x=0} dxdu​∣∣​x=0​ 在上述公式左边使用的是\\left. 右边使用的是\\right ，这样就隐藏了左边的| ，如果不使用\\left. 效果是这样的： dudx∣x=0 \\frac{ {\\rm d}u}{ {\\rm d}x} | _{x=0} dxdu​∣x=0​ 很显然是不美观的，在其他地方，如果我们想隐藏哪边的符号，就在那边的命令后加一个点。 一些常用的括号如下表： 特殊括号 输入 显示 尖括号 \\langle表达式\\rangle ⟨表达式⟩\\langle表达式\\rangle⟨表达式⟩ 向上取整 \\lceil表达式\\rceil ⌈表达式⌉\\lceil表达式\\rceil⌈表达式⌉ 向下取整 \\lfloor表达式\\rfloor ⌊表达式⌋\\lfloor表达式\\rfloor⌊表达式⌋ 大括号 \\lbrace表达式\\rbrace {表达式}\\lbrace表达式\\rbrace{表达式} 一些数学式子和符号 分式 使用\\frac{分子}{分母}来创建一个分式，也可以使用\\frac ab 来快速创建ab\\frac abba​这个分式。 也可以使用 分子\\over 分母”来创建一个分式，此时分式仅有一层。 根式 使用 \\sqrt [根指数]{被开方数} 省略根指数时默认为2 例如：\\sqrt{2} \\quad and \\quad \\sqrt[n]{x+y} 显示为： 2andx+yn \\sqrt{2} \\quad and \\quad \\sqrt[n]{x+y} 2​andnx+y​ 对数 使用\"\\log_{底数}{表达式}\" 其中表达式的大括号可以省略 例如：\\log_{x}y^n 显示为： log⁡xyn \\log_{x}y^n logx​yn 极限 使用“\\lim_{变量 \\to 表达式} 表达式 例如lim_{x \\to +\\infty}\\left(1+\\frac{1}{x}\\right)^x=e显示为： lim⁡x→+∞(1+1x)x=e \\lim_{x \\to +\\infty}\\left(1+\\frac{1}{x}\\right)^x=e x→+∞lim​(1+x1​)x=e 导数 使用 {\\rm d}x 或 {\\text d}x 或 \\text{d}x 均显示为：dx{\\rm d}xdx 偏导数 使用\\frac{\\partial y}{\\partial x} ∂y∂x \\frac{\\partial y}{\\partial x} ∂x∂y​ 梯度 使用\\nabla f(x) ∇f(x) \\nabla f(x) ∇f(x) 向量 使用\\vec{名称}来表示一个向量，例如：\\vec{a} \\cdot \\vec{b}=0\\ 显示为： a⃗⋅b⃗=0 \\vec{a} \\cdot \\vec{b}=0\\ a⋅b=0 积分 定积分、不定积分 使用\\int_0^1 {x^2} \\,{\\rm d}x 表示如下的定积分： ∫01x2 dx \\int_0^1 {x^2} \\,{\\rm d}x ∫01​x2dx 如果想表示不定积分，只需把int后的\\__0^1 去掉即可 多重积分 使用\\iint {x^2} \\,{\\rm d}x{\\rm d}y 表示如下的二重积分，相应地，三重积分只需要改成iiint即可 ∬x2 dxdy \\iint {x^2} \\,{\\rm d}x{\\rm d}y ∬x2dxdy 曲线积分 使用\\oint {2x+y}{\\rm d}s 来表示如下的曲线积分： ∮2x+yds \\oint {2x+y} {\\rm d}s ∮2x+yds 省略号 常见的省略号有以下四种： 用\\ldots表示与文本内容底线对齐的省略号 用 \\cdots 表示于文本内容中线对齐的省略号 用\\vdots表示纵向省略号 用 \\ddots表示斜向省略号。 例如f(x_1,x_2,\\underbrace{\\ldots}_{\\rm ldots} ,x_n) = x_1^2 + x_2^2 + \\underbrace{\\cdots}_{\\rm cdots} + x_n^2 显示为： f(x1,x2,…⏟ldots,xn)=x12+x22+⋯⏟cdots+xn2 f(x_1,x_2,\\underbrace{\\ldots}_{\\rm ldots} ,x_n) = x_1^2 + x_2^2 + \\underbrace{\\cdots}_{\\rm cdots} + x_n^2 f(x1​,x2​,ldots…​​,xn​)=x12​+x22​+cdots⋯​​+xn2​ 最值 使用\\max_{下标表达式}{最值表达式}表示最大值，用 \\min_{下标表达式}{最值表达式}表示最小值。 例如\\max_{1 \\leq x \\leq 2}{e^x}=e^2 显示为： max⁡1≤x≤2ex=e2 \\max_{1 \\leq x \\leq 2}{e^x}=e^2 1≤x≤2max​ex=e2 累加与累乘 累加 使用\\sum_{下限}……{上限}{表达式}表示累加。例如：\\sum_{n=1}^{\\infty} \\frac 1n 显示为： ∑n=1∞1n \\sum_{n=1}^{\\infty} \\frac 1n n=1∑∞​n1​ 累乘 使用\\prod_{下限}^{上限}{表达式}表示累乘。例如：\\prod_{n=1}^{10}{n}显示为： ∏n=110n \\prod_{n=1}^{10}{n} n=1∏10​n 方程组与分段函数 方程组 方程组的表示有两种方法。 使用\\begin{aligned} 12345678$$\\left\\{\\begin{aligned}x+y&amp;=2 \\\\x-y&amp;=4 \\\\\\end{aligned}\\right. % 省略了右边的括号$$ 显示为： {x+y=2x−y=4 \\left\\{ \\begin{aligned} x+y&amp;=2 \\\\ x-y&amp;=4 \\\\ \\end{aligned} \\right. {x+yx−y​=2=4​ 使用\\begin{cases} 123456$$\\begin{cases}x+y=2 \\\\x-y=4 \\\\\\end{cases}$$ 显示为： {x+y=2x−y=4 \\begin{cases} x+y=2 \\\\ x-y=4 \\\\ \\end{cases} {x+y=2x−y=4​ 分段函数 分段函数可以通过\\begin{cases}方式实现，不同与方程组是 表达式和约束条件之间要用&amp;符号隔开。 1234567$$f(x) =\\begin{cases}\\frac{xy}{x^2+y^2} \\qquad &amp; x^2+y^2\\neq0 \\\\0 \\qquad &amp; x^2+y^2=0\\end{cases}$$ 显示为： f(x)={xyx2+y2x2+y2≠00x2+y2=0 f(x) = \\begin{cases} \\frac{xy}{x^2+y^2} \\qquad &amp; x^2+y^2\\neq0 \\\\ 0 \\qquad &amp; x^2+y^2=0 \\end{cases} f(x)={x2+y2xy​0​x2+y2=0x2+y2=0​ 矩阵 方括号矩阵 使用以下方式创建一个方括号矩阵 12345\\begin{bmatrix} %matrix是矩阵的意思 1 &amp; 2 &amp; 3\\\\ 4 &amp; 5 &amp; 6 \\\\ 7 &amp; 8 &amp; 9 %可以通过添加\\\\和&amp;为矩阵添加更多列、行\\end{bmatrix} [123456789] \\begin{bmatrix} 1 &amp; 2 &amp; 3\\\\ 4 &amp; 5 &amp; 6 \\\\ 7 &amp; 8 &amp; 9 \\end{bmatrix} ⎣⎡​147​258​369​⎦⎤​圆括号矩阵 使用以下方式创建一个圆括号矩阵 12345\\begin{pmatrix} 1 &amp; 2 &amp; 3 \\\\ 4 &amp; 5 &amp; 6\\\\ 7 &amp; 8 &amp; 9 %可以通过添加\\\\和&amp;为矩阵添加更多列、行\\end{pmatrix} (123456789) \\begin{pmatrix} 1 &amp; 2 &amp; 3 \\\\ 4 &amp; 5 &amp; 6\\\\ 7 &amp; 8 &amp; 9 \\end{pmatrix} ⎝⎛​147​258​369​⎠⎞​单竖线矩阵 使用以下方式创建一个单竖线矩阵（行列式） 12345\\begin{vmatrix} 1 &amp; 2 &amp; 3\\\\ 4 &amp; 5 &amp; 6\\\\ 7 &amp; 8 &amp; 9\\end{vmatrix} ∣123456789∣ \\begin{vmatrix} 1 &amp; 2 &amp; 3\\\\ 4 &amp; 5 &amp; 6\\\\ 7 &amp; 8 &amp; 9 \\end{vmatrix} ∣∣​147​258​369​∣∣​双竖线矩阵 使用以下方式创建一个双竖线矩阵,与单竖线矩阵不同的是命令中的字母v变成了大写V 12345\\begin{Vmatrix} %变成了大写V1 &amp; 2 &amp; 3\\\\4 &amp; 5 &amp; 6\\\\7 &amp; 8 &amp; 9\\end{Vmatrix} ∥123456789∥ \\begin{Vmatrix} 1 &amp; 2 &amp; 3\\\\ 4 &amp; 5 &amp; 6\\\\ 7 &amp; 8 &amp; 9 \\end{Vmatrix} ∥∥​147​258​369​∥∥​元素省略的矩阵 搭配三种不同的省略号：\\cdots \\vdots \\ddots 可以实现矩阵内元素的省略效果，例如： 123456\\begin{pmatrix} 1 &amp; 2 &amp;\\cdots &amp;3 \\\\ 4 &amp; 5 &amp;\\cdots &amp;6 \\\\ \\vdots &amp; \\vdots &amp;\\ddots &amp; \\vdots \\\\ 7 &amp; 8 &amp;\\cdots &amp; 9 \\end{pmatrix} 显示为以下效果 : (12⋯345⋯6⋮⋮⋱⋮78⋯9) \\begin{pmatrix} 1 &amp; 2 &amp;\\cdots &amp;3 \\\\ 4 &amp; 5 &amp;\\cdots &amp;6 \\\\ \\vdots &amp; \\vdots &amp;\\ddots &amp; \\vdots \\\\ 7 &amp; 8 &amp;\\cdots &amp; 9 \\end{pmatrix} ⎝⎛​14⋮7​25⋮8​⋯⋯⋱⋯​36⋮9​⎠⎞​ 以上就是对一些常见的LaTeX公式的总结，当然，还可以使用在线LaTeX公式编辑器来生成LaTeX代码。","categories":[],"tags":[]},{"title":"基本的markdown语法总结","slug":"基本的markdown语法总结","date":"2022-05-16T15:34:42.345Z","updated":"2022-09-06T01:40:48.884Z","comments":true,"path":"2022/05/16/基本的markdown语法总结/","link":"","permalink":"http://example.com/2022/05/16/%E5%9F%BA%E6%9C%AC%E7%9A%84markdown%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/","excerpt":"markdown是一种轻量级的标记语言，对写博客或者整理笔记很有帮助","text":"markdown是一种轻量级的标记语言，对写博客或者整理笔记很有帮助 Markdown基本语法的整理 首先就是一级标题：用#加一个空格作为开头，后面的内容就是一级标题了。例如，我上面的标题写出来就是“# Markdown基本语法的整理” 类似的用两个#加空格作为二级标题的开头，以此类推… 字体相关 粗体：在想要加粗的内容前后加两个“*\"，就可以把包住的内容加粗。 斜体：在想要斜体的内容前后加一个“*”，就可以把包住的内容加斜。 分隔符：另起一行 ，打上三个“*”，就可以添加分隔符。 删除线：在想要画删除线的内容前后加两个~线。可以实现如下效果：我想删除这一段话 高亮：前后各使用两个=，把需要高亮的内容包裹，效果：高亮。 下划线：前使用&lt;u&gt; 后使用&lt;\\u&gt;包裹需要添加下划线的部分，或直接选中文字后：Ctrl + U 下标：前后使用各使用一个波浪号~包裹下标内容即可，效果：H2O. 上标：前后使用各使用一个^包裹下标内容即可，效果：X2. 换行 段内换行：在段尾敲两个以上的空格再敲回车 段落换行：空一行再敲回车。 如果想空多行可以直接使用“&lt;br&gt;”来换行。 列表 无序列表 可以使用一个*号后面加一个空格来实现，效果为一个黑点，如下： 第一项 第二项 也可以使用+号。或者-号： 第一项 第二项 有序列表 使用任意的数字加一个空格，例如一下效果： 第一 第二 … 在Typora中，只需在第一次输入1. 再次按回车会自动补全数字标序。而如果在上述“第二”前面按Tab键，则上述的第二小项会变成第一小项的一个子项。 任务列表 使用“- [ ]任务一”来添加任务列表，特别注意的是在横杠后和中括号里各有一个空格 任务一 任务二 … 表格 使用 | 来分隔不同的单元格 ，格式如下图所示： 需要注意的是，中间的短横线的数量必须大于等于三个，在表头开始前须空一行。 在Typora中，我们只需要打出上图中的表头部分，软件就会自动帮我们制表。使用Ctrl + Enter 可以为表格添加更多行。 表头 表头 内容 内容 内容 内容 引用 文字等信息的引用 使用一个大于号 &gt; 加一个空格，后面跟的内容就是引用的内容，实际效果如下： 世上无难事，只怕有心人。 如果要嵌套引用，只需在第一个&gt; 后跟上“引用的第一层”，然后敲回车，继续输入&gt; “引用的第二层”： 这是引用的一层 这是第二层 这是第三层 以此类推。如果你想跳出引用，只需敲回车，直至光标显示退出引用。（在Typora中是这样的） 代码的引用 如果是一段文字中的一小部分代码，可以使用一对反引号把你想引用的代码包裹起来即可，例如引用printf(\"hello world!\") 需要强调的是：是用反引号，并非单引号。一般的键盘，反引号在Tab键上面。 如果是一段代码，在这段代码的开始和结束各用三个反引号，并在开始的三个反引号后标注你的代码类型（C、python、java等），例如： 123456#include&lt;stdio.h&gt;int main(){ printf(\"hello world!\"); return 0;} 链接 一个中括号[ ]加一个小括号( )；其中小括号( )里面放地址 例如：我的博客 点击上面的文字，就可以跳转到我的博客主页了。 也可以使用变量来放置地址，例如：我的博客 然后在此篇文章的末尾给变量加上地址上面我的用的是1, 那么我就需要在文章的末尾加上 1: jjwxdu.top 图片 图片的添加，就在上面链接的基础上，在[ ]( )前加一个感叹号！ 对于来源是网络的图片 ！图片 在小括号内( )写上图片的地址 如果是本机图片就在小括号内( )把图片所在的本机地址写上， 建议使用相对路径。 数学公式 行内公式前后各用一个美元符号即可，例如E=MC2E=MC^2E=MC2 , a2+b2=c2a^2+b^2=c^2a2+b2=c2 整行公式，前后各使用两个美元符号包裹即可： ∫0πsin2xdx \\int_0^\\pi sin^2xdx ∫0π​sin2xdx∫0+∞xne−xdx=n! \\int_0^{+\\infty} x^n e^{-x} dx = n! ∫0+∞​xne−xdx=n!其中的数学表达式是遵循Latex语法的，想要掌握，还得学习一些Latex语法。","categories":[],"tags":[]},{"title":"新年快乐","slug":"新年快乐","date":"2022-01-31T05:42:16.840Z","updated":"2022-05-17T15:31:05.421Z","comments":true,"path":"2022/01/31/新年快乐/","link":"","permalink":"http://example.com/2022/01/31/%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90/","excerpt":"又是新的一年了，祝大家新年快乐。","text":"又是新的一年了，祝大家新年快乐。 愿新年胜旧年，愿将来胜过往，我与旧事归于尽，来年依旧迎花开。","categories":[],"tags":[]},{"title":"函数的递归","slug":"函数的递归","date":"2021-11-13T14:13:17.682Z","updated":"2022-05-17T14:58:58.883Z","comments":true,"path":"2021/11/13/函数的递归/","link":"","permalink":"http://example.com/2021/11/13/%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%92%E5%BD%92/","excerpt":"c语言函数递归的总结与运用。","text":"c语言函数递归的总结与运用。 在c语言的函数部分，递归是一块比较难掌握但是又很重要的一个部分。所以就来总结总结遇到的一些问题，以帮助更好的理解与运用递归。 在开始之前，还是先来看看递归的定义。什么是递归呢？简单来讲就是程序调用自身的编程技巧。递归作为一种算法在程序设计语言中广泛应用。一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的但规模较小的问题来求解，递归策略只需少量的程序就可以描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的主要思考方式在于：大事化小，小事化了。 下面通过一个个地例题，我们逐渐认识递归，并总结一些东西。 1.接受一个整型值（无符号），按照顺序打印它的每一位。例如：输入1234，输出1 2 3 4. 123456789#include&lt;stdio.h&gt;void print(unsigned int n)&#123; if(n&gt;9) &#123; print(n/10); &#125; printf(&quot;%d &quot;,n%10);&#125; 通过一层层分析，我们可以了解到这个函数的运行情况。和比较简单的依次输出整数的每一位那一类题不一样，这个题你并不能确定输入的是几位数，但是这个函数就能很好的解决这个问题。就像剥洋葱一样，一层一层地弄开-解决，弄开-解决…同时，我们也不难看出，函数中的选择语句非常重要，正是因为有了那个选择语句，这个递归才有尽头。否则，就是“死循环”。所以，在进行递归时，有两个必要条件： 一, 存在限制条件，当满足这个限制条件的时候。递归便不再继续。 二，每次递归调用之后越来越接近这个限制条件。 例如，在上面一个递归中，限制条件就是n&lt;=9，如果满足这个条件，递归就结束了，每次递归调用之后（n/10），n的值会靠近9这个限制条件。 2.求斐波那契数列第n项的值 斐波那契数列指的是从第三项起，每一项等于前两项之和。因为它的数学关系很明确，所以考虑利用函数的递归来完成。 123456789int Fib(int n)&#123; if(n==1) return 0; else if(n==2) return 1; else return Fib(n-2)+Fib(n-1);&#125; 其实类似于这种的函数递归很容易想明白，因为它具有明显的数学关系：Fib(n)=Fib(n-2)+Fib(n-1),我们只需要利用这个公式进行递归即可。类似地，求这种第n项与前一项有关系的数列的某一项时，可以考虑递归，思维难度低且代码简洁。 3.计算交错序列1-2/3+3/5-4/7+5/9-6/11+…的前N项之和。 12345678910111213141516171819202122232425#define _CRT_SECURE_NO_WARNINGS 1#include&lt;stdio.h&gt;#include&lt;math.h&gt;float A(int n)//函数的递归&#123; if (n == 1) return 1; else if (n % 2 == 0) return -2 - A(n - 1); else return abs(A(n - 1)) + 2;&#125;int main()&#123; int n = 0; scanf(&quot;%d&quot;, &amp;n); double sum = 0; int i = 0; for (i = 1; i &lt;= n; i++) &#123; sum = sum+ (i / A(i)); &#125; printf(&quot;%.3f&quot;, sum); return 0;&#125; 这个题我们容易发现这个数列是有规律的。它的分子和分母分别成等差数列，但是每一项的正负是交替的。这个时候我们想，如果它的每一项都是正值，那也太舒服了，直接利用递归就可以求出每一项的值。but，所以我们它的正负号是交替的，偶数项是负的，奇数项是正的，所以我们只需要在偶数项加一个负号即可。如果只考虑到这，那肯定就错了。因为这是递归，在计算奇数项的值时肯定会利用偶数项的值计算，如果我们只是给偶数项加一个负号，那么奇数项的值就出错了。这个时候我们考虑价格绝对值，把奇数项递归时的值变成正值。其实，对于我来说这个地方还是挺难想的，一不小心进去就出不来了（想不明白了）。。。。细品，品。。。 4.求阶乘 以一个简单的问题收尾，因为这篇文章实在是拖太久了（懒）。。。 1234567int Mul(int n)&#123; if(n==1) return 1; else return n*Mul(n-1);&#125; 万变不离其宗，这个问题其实和斐波那契数列那个问题一样，都是两项之间有明确的数学关系。n！=n*【（n-1！）】，只要能找到这个关系，这类问题就可以很轻松的解决。 函数的递归其实还是比较费脑筋的，尤其是遇到一些问题你不知道怎么去构造递归，就很麻烦。持续总结一些问题，积累积累经验。常更新（划掉）","categories":[],"tags":[]},{"title":"c语言--函数","slug":"c语言--函数","date":"2021-10-26T11:32:38.636Z","updated":"2022-05-17T14:58:52.895Z","comments":true,"path":"2021/10/26/c语言--函数/","link":"","permalink":"http://example.com/2021/10/26/c%E8%AF%AD%E8%A8%80--%E5%87%BD%E6%95%B0/","excerpt":"初识c语言，东西比较杂乱，所以写来整理，以便后续复习。","text":"初识c语言，东西比较杂乱，所以写来整理，以便后续复习。 1，先看最近遇到的一个问题：写一个函数，它的功能是使a,b两个变量的值交换。 函数的写法如下： 1234567void swap1(int x, int y)//函数定义&#123; int z=0;//引入一个中间变量 z=x; x=y; y=z;&#125; 然后在主函数使用它： 123456789include&lt;stdio.h&gt;int main()&#123; int a=20; int b=10; swap1(a,b);//函数调用 printf(&quot;%d %d&quot;,a,b); return 0;&#125; 编译运行后发现：a=20,b=10.也就是说a和b的值并没有交换，写的交换函数出问题了。但回过头来看一看，函数写的好像确实“一点问题都没有”，于是，我们调试这个代码，并监视a，b，x，y的值，发现：当a和b把值传给x，y的时候，x=a=20；y=b=10; 经过函数的作用：x=b=10 ; y=a=20; 终于，明白了问题所在：其实，这个程序交换的是x和y的值，并没有对a和b的值进行交换，但这并不是我们想要的；进一步监视&amp;a，&amp;b发现了这个问题的本质：当a和b把值传给x和y时，x和y在内存中分别开辟了一个空间，这个空间的地址不同于a和b，也就是说我们无论进行什么操作，都是对x和y操作的，并不会对a和b的值产生什么影响。于是我们对这个程序进行改进，使函数内部是对a和b进行操作的。改进后的函数如下： 1234567void swap2(int* pa, int* pb)//这里的pa和pb是指针变量，用来接收a和b的地址//函数定义&#123; int z=0;//引入一个中间变量 z=*pa; *pa=*pb; *pb=z;&#125; 再把主函数内的swap(a,b)改为swap(&amp;a,&amp;b),这样就把a和b的地址传给swap函数，用指针变量去接收地址，就可以完成值的交换。 其中在函数定义中的x和y，称之为形式参数 (形参)【可以是常量，变量，表达式，函数等】；在函数调用中的a和b称之为实际参数 (实参)【只有在函数被调用的时候才会实例化（分配内存单元）且在函数调用完成之后就自动销毁了，只在函数中有效】 swap1在被调用的时候，实参传给形参，其实形参是实参的一份临时拷贝。所以，改变形参，并不会改变实参。但是swap2中的pa和pb和a，b是对应的。 2，写一个函数，判断它是否为素数 首先，我们要明确如何判断一个数是不是质数，然后再考虑怎么去实现它。 简单的一个思路就是：假设这个数是n，然后n分别除以2——(n-1)(亦或者根号n) 对于依次做除法，可以利用for循环实现，但我们还得考虑，进行完除法操作后，还应该怎么办才能让这个函数发挥作用。 在这里，我用函数的返回值作为信息，以便于在调用时方便使用，即：如果这个数是素数就返回1，否则返回0； 具体函数如下：（这里我们需要判断的数均是大于等于2的） 123456789101112int prime_judge(int x)&#123; int i=0; for(i=2;i&lt;x;i++) &#123; if(x%i==0) &#123; return 0; &#125; &#125; return 1;&#125; 在程序中调用这个函数： 123456789101112131415#include&lt;stdio.h&gt;int main()&#123; int n=0; scanf(&quot;%d&quot;,&amp;n); if(prime_judge(n)==1)//利用选择语句，结合返回值进行判断 &#123; printf(&quot;%d is a prime.&quot;,n); &#125; else &#123; printf(&quot;%d is not a prime.&quot;,n); &#125; return 0；&#125; 以上是我的一个小总结，有时间还会总结更多的例子。 3，函数的调用： 函数的调用分为两类，一类是：传值调用(不需要改变主函数中的变量的值，只是把值传过去用一下)；另一类是：传址调用（把地址传给子函数，需要时可以改变主函数中变量的值）； 4，函数的嵌套调用和链式访问 在c语言的函数中，函数可以嵌套调用：可以在一个函数的内部调用（使用）另一个函数。但是，函数是不可以嵌套定义的：在定义函数的时候，一个函数内部不可以再定义一个函数； 链式访问：简单地来说，就是把一个函数的返回值作为另一个函数的参数； e.g 1printf(&quot;%d\\n&quot;,strlen(&quot;abc&quot;)); 在这里strlen函数的返回值作为了printf函数的参数； 值得注意的是：如果把函数定义在了主函数之后，那么在使用子函数的时候遵循**“先声明，后使用”**的原则，告诉编译器有一个函数叫什么，参数是什么，返回类型是什么。","categories":[],"tags":[]},{"title":"我的第一篇博客","slug":"我的第一篇博客","date":"2021-10-22T11:53:42.721Z","updated":"2022-05-17T14:59:13.951Z","comments":true,"path":"2021/10/22/我的第一篇博客/","link":"","permalink":"http://example.com/2021/10/22/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"历时将近半个月，我的博客终于上线啦！这是我在这里写下的第一篇文章","text":"历时将近半个月，我的博客终于上线啦！这是我在这里写下的第一篇文章 弄完博客后，我写下这篇文章来总结这次的经历和我两个月的大学生活。 首先是这次搭建博客，着实不易，在网上搜索教程，一步一步照猫画虎，但你还是会遇到各种错误，如果你足够幸运：你遇到的错误大多数人都遇到了，你可以很容易地在网上找到解决这个错误的方法。但，如果你的脸很黑：hhhh，几乎没人和你有同样的错误，或者是别人的解决方案并不适用于你。。。。不幸的是我每次遇到的问题属于脸黑型，在中途有过放弃的念想。每次整累了，快崩了，就放一放。有些问题，自己就没了（我也不知道为啥） 整个过程把“山重水复疑无路，柳暗花明又一村”体现的淋漓尽致。其实越是这种“尴尬”的局面，就越需要心态，有时候它真的可以决定最后的结果。 再说说自己这两个月的大学生活吧，说来惭愧，这两个月过的确实很一般。自己没有想象中的那么充满斗志，状态也只是满足于上课。也许是刚经历了紧绷的高三，现在一有时间就想给自己放假，没有明白自己想要做好什么事。以前高三的时候，下午吃完饭总会把渴望的眼光投向窗外的操场，然后观望一会就继续写题，想着大学时间多了，要多去操场遛一遛。然而，上了大学的实际情况是：这学期的体育打卡一次还没打。。。。。（真尴尬），真正迈进大学的校园，我才发现我正在迷茫的旋涡中挣扎，也许是大多数学生的共同特点，不知道自己将来会面临什么，也不知道自己应该做什么。希望自己能更快的适应大学生活，找到自己真正的热爱。 文字水平较差，我写完读起来，自己也会有尴尬的感觉，嘿嘿嘿… ——end——","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-10-16T14:33:00.973Z","updated":"2021-10-22T09:55:18.175Z","comments":true,"path":"2021/10/16/hello-world/","link":"","permalink":"http://example.com/2021/10/16/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}